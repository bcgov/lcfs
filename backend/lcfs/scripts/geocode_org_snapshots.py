"""
Organization Snapshot Geocoding Script

This script extracts addresses from compliance_report_organization_snapshot,
geocodes them using the BC Geocoder service, and outputs SQL UPDATE statements.

Usage:
    cd backend
    poetry run python -m lcfs.scripts.geocode_org_snapshots

Output:
    Creates: org_snapshot_coordinates.sql (in current directory)

Then run the SQL manually:
    psql -h localhost -U lcfs -d lcfs -f org_snapshot_coordinates.sql
"""

import asyncio
import sys
from pathlib import Path

# Add backend to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

import redis.asyncio as redis
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.engine import make_url

from lcfs.settings import settings
from lcfs.services.geocoder.client import BCGeocoderService


async def get_unique_addresses(session: AsyncSession) -> list[dict]:
    """Extract unique addresses from organization snapshots.

    Priority for geocoding:
    1. records_address - Required to be in BC where records are maintained
    2. service_address - BC postal address for service
    3. head_office_address - Can be international, last resort
    """
    query = text("""
        SELECT DISTINCT ON (COALESCE(records_address, service_address, head_office_address))
            organization_snapshot_id,
            records_address,
            service_address,
            head_office_address,
            name,
            COALESCE(records_address, service_address, head_office_address) as primary_address
        FROM compliance_report_organization_snapshot
        WHERE (records_address IS NOT NULL AND records_address != '')
           OR (service_address IS NOT NULL AND service_address != '')
           OR (head_office_address IS NOT NULL AND head_office_address != '')
        AND latitude IS NULL
        ORDER BY COALESCE(records_address, service_address, head_office_address), organization_snapshot_id
    """)

    result = await session.execute(query)
    rows = result.fetchall()

    return [
        {
            "organization_snapshot_id": row[0],
            "records_address": row[1],
            "service_address": row[2],
            "head_office_address": row[3],
            "name": row[4],
            "primary_address": row[5],
        }
        for row in rows
    ]


async def geocode_addresses(
    geocoder: BCGeocoderService,
    addresses: list[dict]
) -> list[dict]:
    """Geocode addresses and return results with coordinates.

    Tries addresses in priority order:
    1. records_address (BC location where records are maintained)
    2. service_address (BC postal address)
    3. head_office_address (can be international)
    """
    results = []
    total = len(addresses)

    for i, addr_info in enumerate(addresses, 1):
        primary_addr = addr_info["primary_address"]
        records_addr = addr_info.get("records_address")
        service_addr = addr_info.get("service_address")
        head_office_addr = addr_info.get("head_office_address")

        print(f"[{i}/{total}] Geocoding: {primary_addr[:60]}...")

        result = None

        # Try addresses in priority order
        for addr, addr_type in [
            (records_addr, "records_address"),
            (service_addr, "service_address"),
            (head_office_addr, "head_office_address"),
        ]:
            if addr:
                result = await geocoder.forward_geocode(addr, use_fallback=True)
                if result.success:
                    print(f"  -> Success via {addr_type}")
                    break
                else:
                    print(f"  -> {addr_type} failed, trying next...")

        if result and result.success and result.address:
            # Only store ID and coordinates - no identifying information
            results.append({
                "organization_snapshot_id": addr_info["organization_snapshot_id"],
                "latitude": result.address.latitude,
                "longitude": result.address.longitude,
            })
        else:
            print(f"  -> All addresses failed")

    return results


def write_sql(results: list[dict], output_path: Path):
    """Write SQL UPDATE statements for manual execution."""
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("-- Organization Snapshot Coordinates Update\n")
        f.write("-- Generated by geocode_org_snapshots.py\n")
        f.write(f"-- Total records: {len(results)}\n\n")
        f.write("BEGIN;\n\n")

        for r in results:
            f.write(
                f"UPDATE compliance_report_organization_snapshot "
                f"SET latitude = {r['latitude']}, longitude = {r['longitude']} "
                f"WHERE organization_snapshot_id = {r['organization_snapshot_id']};\n"
            )

        f.write("\nCOMMIT;\n")

    print(f"\nWritten {len(results)} UPDATE statements to {output_path}")


async def main():
    print("=" * 60)
    print("Organization Snapshot Geocoding Script")
    print("=" * 60)

    # Setup database connection
    db_url = make_url(str(settings.db_url))
    engine = create_async_engine(db_url, future=True)

    # Setup Redis for geocoder cache
    redis_client = redis.Redis(
        host=settings.redis_host,
        port=settings.redis_port,
        password=settings.redis_pass,
        decode_responses=False
    )

    # Initialize geocoder
    geocoder = BCGeocoderService(
        redis_client=redis_client,
        cache_ttl=86400  # 24 hour cache
    )

    try:
        async with AsyncSession(engine) as session:
            # Get addresses to geocode
            print("\nFetching addresses from database...")
            addresses = await get_unique_addresses(session)
            print(f"Found {len(addresses)} unique addresses to geocode")

            if not addresses:
                print("No addresses need geocoding. Exiting.")
                return

            # Geocode addresses
            print("\nStarting geocoding...")
            results = await geocode_addresses(geocoder, addresses)

            # Write SQL file to current directory (not committed to repo)
            output_path = Path.cwd() / "org_snapshot_coordinates.sql"

            # Write results as SQL
            write_sql(results, output_path)

            # Summary
            successful = len(results)
            failed = len(addresses) - successful
            print(f"\nSummary:")
            print(f"  Total addresses: {len(addresses)}")
            print(f"  Successful: {successful}")
            print(f"  Failed: {failed}")

    finally:
        await geocoder.shutdown()
        await redis_client.close()
        await engine.dispose()


if __name__ == "__main__":
    asyncio.run(main())

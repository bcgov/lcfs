name: LCFS 1.0.0 Prod CI

permissions:
  contents: write
  actions: read
  issues: read

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VERSION: 1.0.0
  GIT_URL: https://github.com/bcgov/lcfs.git
  TOOLS_NAMESPACE: ${{ secrets.OPENSHIFT_NAMESPACE_PLATE }}-tools
  PROD_NAMESPACE: ${{ secrets.OPENSHIFT_NAMESPACE_PLATE }}-prod

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  install-oc:
    runs-on: ubuntu-latest
    outputs:
      cache-hit: ${{ steps.cache.outputs.cache-hit }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4.1.1

      - name: Set up cache for OpenShift CLI
        id: cache
        uses: actions/cache@v4.2.0
        with:
          path: /usr/local/bin/oc # Path where the `oc` binary will be installed
          key: oc-cli-${{ runner.os }}

      - name: Install OpenShift CLI (if not cached)
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz
          tar -xvf openshift-client-linux.tar.gz
          sudo mv oc /usr/local/bin/
          oc version --client

      - name: Confirm OpenShift CLI is Available
        run: oc version --client

  # ---------- Backend: Setup â†’ Sharded Tests â†’ Publish ----------
  backend-setup:
    name: "Backend Setup"
    runs-on: ubuntu-latest
    needs: [install-oc]
    outputs:
      setup-complete: ${{ steps.setup-complete.outputs.complete }}
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_DB: lcfs
          POSTGRES_USER: lcfs
          POSTGRES_PASSWORD: development_only
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            backend

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10.13"

      - name: Cache Poetry dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pypoetry
            backend/.venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}-${{ hashFiles('backend/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}-
            ${{ runner.os }}-poetry-

      - name: Install Poetry
        run: pip install poetry==1.6.1

      - name: Install backend dependencies
        run: |
          pip install --upgrade pip setuptools wheel
          cd backend
          poetry install

      - name: Wait for PostgreSQL to be ready
        run: |
          CONTAINER_ID=$(docker ps -q -f "ancestor=postgres:17")
          until docker exec $CONTAINER_ID pg_isready -U lcfs; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          echo "PostgreSQL is ready!"

      - name: Run migrations and create template database
        run: |
          cd backend
          poetry run alembic upgrade heads
        env:
          LCFS_DB_HOST: localhost
          LCFS_DB_PORT: 5432
          LCFS_DB_USER: lcfs
          LCFS_DB_PASS: development_only
          LCFS_DB_BASE: lcfs

      - name: Create database dump with compatibility options
        run: |
          CONTAINER_ID=$(docker ps -q -f "ancestor=postgres:17")
          if [ -z "$CONTAINER_ID" ]; then
            echo "Error: PostgreSQL container not found"
            exit 1
          fi

          docker exec $CONTAINER_ID pg_dump -U lcfs -d lcfs \
            --no-owner \
            --no-privileges \
            --no-comments \
            --create \
            --clean \
            --if-exists \
            --format=custom \
            --compress=6 > lcfs_template.pgdump

          if [ ! -s lcfs_template.pgdump ]; then
            echo "Error: Database dump is empty or failed"
            exit 1
          fi

          echo "Database dump created successfully ($(stat --printf=%s lcfs_template.pgdump) bytes)"

      - name: Upload database template
        uses: actions/upload-artifact@v4
        with:
          name: db-template
          path: lcfs_template.pgdump
          retention-days: 1
          compression-level: 9

      - name: Mark setup as complete
        id: setup-complete
        run: echo "complete=true" >> $GITHUB_OUTPUT

  backend-tests:
    name: "Backend Tests (Shard ${{ matrix.shard }}/${{ strategy.job-total }})"
    needs: backend-setup
    runs-on: ubuntu-latest
    if: needs.backend-setup.outputs.setup-complete == 'true'
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_DB: lcfs
          POSTGRES_USER: lcfs
          POSTGRES_PASSWORD: development_only
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    strategy:
      matrix:
        shard:
          [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
          ]
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            backend

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10.13"

      - name: Cache Poetry dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pypoetry
            backend/.venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}-${{ hashFiles('backend/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}-
            ${{ runner.os }}-poetry-

      - name: Install Poetry
        run: pip install poetry==1.6.1

      - name: Install backend dependencies
        run: |
          pip install --upgrade pip setuptools wheel
          cd backend
          poetry install

      - name: Cache pytest timing data
        uses: actions/cache@v4
        with:
          path: backend/.pytest_cache
          key: ${{ runner.os }}-pytest-timing-${{ strategy.job-total }}-${{ hashFiles('backend/lcfs/tests/**/*.py') }}
          restore-keys: |
            ${{ runner.os }}-pytest-timing-${{ strategy.job-total }}-

      - name: Wait for PostgreSQL to be ready
        run: |
          CONTAINER_ID=$(docker ps -q -f "ancestor=postgres:17")
          until docker exec $CONTAINER_ID pg_isready -U lcfs; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          echo "PostgreSQL is ready!"

      - name: Download database template
        uses: actions/download-artifact@v4
        with:
          name: db-template
          path: .

      - name: Verify database template
        run: |
          if [ ! -f lcfs_template.pgdump ]; then
            echo "Error: Database template file not found"
            exit 1
          fi
          if [ ! -s lcfs_template.pgdump ]; then
            echo "Error: Database template file is empty"
            exit 1
          fi
          echo "Database template verified ($(stat --printf=%s lcfs_template.pgdump) bytes)"

      - name: Setup shard-specific database
        run: |
          CONTAINER_ID=$(docker ps -q -f "ancestor=postgres:17")
          docker exec $CONTAINER_ID createdb -U lcfs lcfs_shard_${{ matrix.shard }}
          docker cp lcfs_template.pgdump $CONTAINER_ID:/tmp/lcfs_template.pgdump
          docker exec $CONTAINER_ID pg_restore \
            -U lcfs \
            -d lcfs_shard_${{ matrix.shard }} \
            --no-owner \
            --no-privileges \
            --disable-triggers \
            --single-transaction \
            --exit-on-error \
            --verbose \
            /tmp/lcfs_template.pgdump
        env:
          LCFS_DB_HOST: localhost
          LCFS_DB_PORT: 5432
          LCFS_DB_USER: lcfs
          LCFS_DB_PASS: development_only

      - name: Ensure pytest cache directory exists
        run: |
          cd backend
          mkdir -p .pytest_cache

      - name: Run backend tests for shard
        id: backend_tests
        run: |
          cd backend
          poetry run pytest --splits ${{ strategy.job-total }} --group ${{ matrix.shard }} --store-durations --maxfail=1 --tb=short --disable-warnings --quiet --junitxml=pytest-results-shard-${{ matrix.shard }}.xml || [ $? -eq 5 ]
        env:
          LCFS_DB_HOST: localhost
          LCFS_DB_PORT: 5432
          LCFS_DB_USER: lcfs
          LCFS_DB_PASS: development_only
          LCFS_DB_BASE: lcfs_shard_${{ matrix.shard }}
          LCFS_REDIS_HOST: localhost
          LCFS_REDIS_PORT: 6379
          LCFS_REDIS_PASSWORD: development_only
          APP_ENVIRONMENT: dev
          LCFS_CHES_CLIENT_ID: mock_client_id
          LCFS_CHES_CLIENT_SECRET: mock_client_secret
          LCFS_CHES_AUTH_URL: http://mock_auth_url
          LCFS_CHES_SENDER_EMAIL: noreply@gov.bc.ca
          LCFS_CHES_SENDER_NAME: Mock Notification System
          LCFS_CHES_EMAIL_URL: http://mock_email_url

      - name: Upload pytest results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results-shard-${{ matrix.shard }}
          path: backend/pytest-results-shard-${{ matrix.shard }}.xml
          retention-days: 1

  # ---------- Frontend: Setup â†’ Sharded Tests â†’ Publish ----------
  frontend-setup:
    name: "Frontend Setup"
    runs-on: ubuntu-latest
    outputs:
      setup-complete: ${{ steps.setup-complete.outputs.complete }}
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            frontend

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: frontend/node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci --prefer-offline --no-audit --no-fund

      - name: Type Check Frontend (parallel)
        run: |
          cd frontend
          npm run type-check &
          TYPE_CHECK_PID=$!
          wait $TYPE_CHECK_PID

      - name: Cache node_modules for test shards
        uses: actions/cache@v4
        with:
          path: frontend/node_modules
          key: ${{ runner.os }}-node-modules-shared-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-shared-

      - name: Mark setup as complete
        id: setup-complete
        run: echo "complete=true" >> $GITHUB_OUTPUT

  frontend-tests:
    name: "Frontend Tests (Shard ${{ matrix.shardIndex }}/${{ matrix.shardTotal }})"
    needs: frontend-setup
    runs-on: ubuntu-latest
    if: needs.frontend-setup.outputs.setup-complete == 'true'
    strategy:
      matrix:
        shardIndex:
          [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
          ]
        shardTotal: [32]
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            frontend

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Restore node_modules cache
        uses: actions/cache@v4
        with:
          path: frontend/node_modules
          key: ${{ runner.os }}-node-modules-shared-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-shared-
            ${{ runner.os }}-node-modules-

      - name: Install frontend dependencies (fallback)
        run: |
          cd frontend
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit --no-fund
          fi

      - name: Run frontend tests
        id: frontend_tests
        run: |
          cd frontend
          echo "=== Running tests for shard ${{ matrix.shardIndex }}/${{ matrix.shardTotal }} ==="

          set +e
          npm run test:ci:memory
          EXIT_CODE=$?
          set -e

          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… Tests completed successfully"
          elif [ $EXIT_CODE -eq 1 ]; then
            echo "Checking if shard ${{ matrix.shardIndex }} is empty..."
            if SHARD_INDEX=${{ matrix.shardIndex }} SHARD_TOTAL=${{ matrix.shardTotal }} node --max-old-space-size=8192 ./node_modules/.bin/vitest run --reporter=verbose --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }} --run=false 2>&1 | grep -q "No test files found"; then
              echo "âœ… Empty shard detected - letting merge step handle missing report"
            else
              echo "âŒ Real test failure detected in shard ${{ matrix.shardIndex }}"
              exit $EXIT_CODE
            fi
          else
            echo "âŒ Tests failed with unexpected exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi
        env:
          CI: true
          SHARD_INDEX: ${{ matrix.shardIndex }}
          SHARD_TOTAL: ${{ matrix.shardTotal }}
          VITEST_REPORTER: "blob"
          VITEST_POOL_THREADS: "4"

      - name: Debug test failure details
        if: failure()
        run: |
          cd frontend
          echo "=== FRONTEND TEST FAILURE DEBUG ==="
          echo "Failed shard: ${{ matrix.shardIndex }}/${{ matrix.shardTotal }}"
          echo "Memory settings: 8192MB (npm script)"
          echo "Environment: CI=$CI"
          echo ""
          echo "Getting detailed error information..."
          SHARD_INDEX=${{ matrix.shardIndex }} SHARD_TOTAL=${{ matrix.shardTotal }} node --max-old-space-size=8192 ./node_modules/.bin/vitest run --reporter=verbose --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }} || true
        env:
          CI: true

      - name: Upload blob report to GitHub Actions Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: blob-report-${{ matrix.shardIndex }}
          path: frontend/.vitest-reports/*
          include-hidden-files: true
          retention-days: 1
          compression-level: 9

  # ---------- Build/Deploy/Release (unchanged logic, updated needs) ----------
  set-pre-release:
    name: Calculate pre-release number
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    outputs:
      PRE_RELEASE: ${{ steps.set-pre-release.outputs.PRE_RELEASE }}
    steps:
      - id: set-pre-release
        run: echo "PRE_RELEASE=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_OUTPUT

  build:
    name: Build LCFS
    runs-on: ubuntu-latest
    needs: [set-pre-release]
    timeout-minutes: 60
    env:
      PRE_RELEASE: ${{ needs.set-pre-release.outputs.PRE_RELEASE }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4.1.1

      - name: Restore oc command from Cache
        uses: actions/cache@v4.2.0
        with:
          path: /usr/local/bin/oc
          key: oc-cli-${{ runner.os }}

      - name: Log in to Openshift
        uses: redhat-actions/oc-login@v1.3
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          insecure_skip_tls_verify: true
          namespace: ${{ env.TOOLS_NAMESPACE }}

      - name: Build LCFS Backend
        run: |
          cd openshift/templates
          oc process -f ./backend-bc.yaml VERSION=${{ env.VERSION }}-${{ env.PRE_RELEASE }} GIT_URL=${{ env.GIT_URL }} GIT_REF=main | oc apply --wait=true -f - -n ${{ env.TOOLS_NAMESPACE }}
          sleep 2s
          oc -n ${{ env.TOOLS_NAMESPACE }} start-build lcfs-backend-${{ env.VERSION }}-${{ env.PRE_RELEASE }} --wait=true

      - name: Build LCFS Frontend
        run: |
          cd openshift/templates
          oc process -f ./frontend-bc.yaml VERSION=${{ env.VERSION }}-${{ env.PRE_RELEASE }} GIT_URL=${{ env.GIT_URL }} GIT_REF=main | oc apply --wait=true -f - -n ${{ env.TOOLS_NAMESPACE }}
          sleep 2s
          oc -n ${{ env.TOOLS_NAMESPACE }} start-build lcfs-frontend-${{ env.VERSION }}-${{ env.PRE_RELEASE }} --wait=true

      - name: Tag the source code
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          prodtag="${{ env.VERSION }}-${{ env.PRE_RELEASE }}"
          git tag $prodtag
          git push origin $prodtag

  deploy-on-prod:
    name: Deploy LCFS on Prod
    runs-on: ubuntu-latest
    needs: [set-pre-release, build]
    timeout-minutes: 60
    env:
      PRE_RELEASE: ${{ needs.set-pre-release.outputs.PRE_RELEASE }}
    steps:
      - name: Ask for approval for LCFS ${{env.IMAGE_TAG }} Prod deployment
        uses: trstringer/manual-approval@v1.6.0
        with:
          secret: ${{ github.TOKEN }}
          approvers: AlexZorkin,kuanfandevops,hamed-valiollahi,airinggov,prv-proton,Grulin
          minimum-approvals: 2
          issue-title: "LCFS ${{env.VERSION }}-${{env.PRE_RELEASE }} Prod Deployment."

      - name: Checkout Manifest repository
        uses: actions/checkout@v3
        with:
          repository: bcgov-c/tenant-gitops-d2bd59
          ref: main
          ssh-key: ${{ secrets.MANIFEST_REPO_DEPLOY_KEY }}

      - name: Restore oc command from Cache
        uses: actions/cache@v4.2.0
        with:
          path: /usr/local/bin/oc
          key: oc-cli-${{ runner.os }}

      - name: Log in to Openshift
        uses: redhat-actions/oc-login@v1.3
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          insecure_skip_tls_verify: true
          namespace: ${{ env.PROD_NAMESPACE }}

      - name: Tag LCFS images from Test to Prod
        run: |
          oc tag ${{ env.TOOLS_NAMESPACE }}/lcfs-backend:${{env.VERSION }}-${{env.PRE_RELEASE }} ${{ env.PROD_NAMESPACE }}/lcfs-backend:${{env.VERSION }}-${{env.PRE_RELEASE }}
          oc tag ${{ env.TOOLS_NAMESPACE }}/lcfs-frontend:${{env.VERSION }}-${{env.PRE_RELEASE }} ${{ env.PROD_NAMESPACE }}/lcfs-frontend:${{env.VERSION }}-${{env.PRE_RELEASE }}

      - name: Update frontend tag for prod deployment
        uses: mikefarah/yq@v4.40.5
        with:
          cmd: |
            yq -i '.image.tag = "${{env.VERSION }}-${{env.PRE_RELEASE }}"' lcfs/charts/lcfs-frontend/values-prod.yaml
            yq -i '.image.tag = "${{env.VERSION }}-${{env.PRE_RELEASE }}"' lcfs/charts/lcfs-backend/values-prod.yaml
            yq -i '.image.tag = "${{env.VERSION }}-${{env.PRE_RELEASE }}"' lcfs/charts/lcfs-dynamic-scheduler/values-prod.yaml

      - name: GitHub Commit & Push
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git add lcfs/charts/lcfs-frontend/values-prod.yaml
          git add lcfs/charts/lcfs-backend/values-prod.yaml
          git add lcfs/charts/lcfs-dynamic-scheduler/values-prod.yaml
          git commit -m "Update image tag ${{env.VERSION }}-${{env.PRE_RELEASE }} for prod"
          git push

  create-release:
    name: Create release after prod deployment
    runs-on: ubuntu-latest
    needs: [set-pre-release, deploy-on-prod]
    env:
      PRE_RELEASE: ${{ needs.set-pre-release.outputs.PRE_RELEASE }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4.1.1

      - name: Fetch tags
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git fetch --tags
          git tag -l

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Automatically provided by GitHub
        with:
          tag_name: "${{env.VERSION }}-${{env.PRE_RELEASE }}" # The pushed tag
          release_name: "${{env.VERSION }}-${{env.PRE_RELEASE }}" # Release title
          body: "This is an automated release ðŸš€" # Release notes
          draft: false # Set to true if you want a draft release
          prerelease: false
